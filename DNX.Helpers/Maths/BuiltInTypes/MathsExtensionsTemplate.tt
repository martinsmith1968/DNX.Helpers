<#@ template debug="false" hostspecific="True" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ include file="..\..\MultipleOutputHelper.ttinclude" #>
<# // http://mariusbancila.ro/blog/2012/09/03/t4-lessons-learned/ #>
<# var manager = Manager.Create(Host, GenerationEnvironment); #>
<#
var types = new Dictionary<string, string>()
{
    { "Byte", "byte" },
    { "SByte", "sbyte" },

    { "DateTime", "DateTime" },

    { "Int16", "short" },
    { "UInt16", "ushort" },

    { "Int32", "int" },
    { "UInt32", "uint" },

    { "Int64", "long" },
    { "UInt64", "ulong" },

    { "Float", "float" },
    { "Double", "double" },
    { "Decimal", "decimal" },
};

bool CanConvertToHexString(string typeName)
{
    if (typeName == "DateTime") return false;
    if (typeName == "decimal") return false;
    if (typeName == "double") return false;
    if (typeName == "float") return false;

    return true;
}
#>
<# manager.StartHeader(); #>
// Code generated by a Template
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace DNX.Helpers.Maths.BuiltInTypes
{
<# manager.EndBlock(); #>
<#
foreach (var kvp in types)
{
    var typeName = kvp.Value;
    var typeDesc = kvp.Key;
    var fileName = string.Format("Maths{0}Extensions.generated.cs", typeDesc);

    manager.StartNewFile(fileName);
#>
    /// <summary>
    /// Class Maths<#= typeDesc #>Extensions.
    /// </summary>
    public static class Maths<#= typeDesc #>Extensions
    {
        /// <summary>
        /// Determines whether the specified value is inclusively between min and max.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <param name="min">The minimum.</param>
        /// <param name="max">The maximum.</param>
        /// <returns><c>true</c> if the specified minimum is between min and max; otherwise, <c>false</c>.</returns>
        public static bool IsBetween(this <#= typeName #> value, <#= typeName #> min, <#= typeName #> max)
        {
            return value.IsBetween(min, max, IsBetweenBoundsType.Inclusive);
        }

        /// <summary>
        /// Determines whether the specified value is between min and max.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <param name="min">The minimum.</param>
        /// <param name="max">The maximum.</param>
        /// <param name="boundsType">Control boundary checking.</param>
        /// <returns><c>true</c> if the specified minimum is between; otherwise, <c>false</c>.</returns>
        public static bool IsBetween(this <#= typeName #> value, <#= typeName #> min, <#= typeName #> max, IsBetweenBoundsType boundsType)
        {
            return value.IsBetween(min, max, false, boundsType);
        }

        /// <summary>
        /// Determines whether the specified value is inclusively between the smaller of min and max and the larger of min and max.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <param name="min">The minimum.</param>
        /// <param name="max">The maximum.</param>
        /// <returns><c>true</c> if the specified minimum is between min and max; otherwise, <c>false</c>.</returns>
        public static bool IsBetweenEither(this <#= typeName #> value, <#= typeName #> min, <#= typeName #> max)
        {
            return value.IsBetweenEither(min, max, IsBetweenBoundsType.Inclusive);
        }

        /// <summary>
        /// Determines whether the specified value is between the smaller of min and max and the larger of min and max.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <param name="min">The minimum.</param>
        /// <param name="max">The maximum.</param>
        /// <param name="boundsType">Control boundary checking.</param>
        /// <returns><c>true</c> if [is between either] [the specified minimum]; otherwise, <c>false</c>.</returns>
        public static bool IsBetweenEither(this <#= typeName #> value, <#= typeName #> min, <#= typeName #> max, IsBetweenBoundsType boundsType)
        {
            return value.IsBetween(min, max, true, boundsType);
        }

        /// <summary>
        /// Determines whether the specified value is between min and max with full control over bounds checking.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <param name="min">The minimum.</param>
        /// <param name="max">The maximum.</param>
        /// <param name="allowEitherOrder">if set to <c>true</c> allow min/max in either order.</param>
        /// <param name="boundsType">Control boundary checking.</param>
        /// <returns><c>true</c> if the specified minimum is between min and max; otherwise, <c>false</c>.</returns>
        public static bool IsBetween(this <#= typeName #> value, <#= typeName #> min, <#= typeName #> max, bool allowEitherOrder, IsBetweenBoundsType boundsType)
        {
            var lowerBound = GetLowerBound(min, max, allowEitherOrder);
            var upperBound = GetUpperBound(min, max, allowEitherOrder);

            switch (boundsType)
            {
                case IsBetweenBoundsType.IncludeLowerAndUpper:
                    return (value >= lowerBound) && (value <= upperBound);

                case IsBetweenBoundsType.ExcludeLowerAndUpper:
                    return (value > lowerBound) && (value < upperBound);

                case IsBetweenBoundsType.IncludeLowerExcludeUpper:
                    return (value >= lowerBound) && (value < upperBound);

                case IsBetweenBoundsType.ExcludeLowerIncludeUpper:
                    return (value > lowerBound) && (value <= upperBound);

                default:
                    return false;
            }
        }

        /// <summary>
        /// Gets the lower bound.
        /// </summary>
        /// <param name="min">The minimum.</param>
        /// <param name="max">The maximum.</param>
        /// <param name="allowEitherOrder">if set to <c>true</c> allow min/max in either order</param>
        /// <returns><#= typeName #></returns>
        public static <#= typeName #> GetLowerBound(<#= typeName #> min, <#= typeName #> max, bool allowEitherOrder)
        {
            return allowEitherOrder
                ? min < max
                    ? min
                    : max
                : min;
        }

        /// <summary>
        /// Gets the upper bound.
        /// </summary>
        /// <param name="min">The minimum.</param>
        /// <param name="max">The maximum.</param>
        /// <param name="allowEitherOrder">if set to <c>true</c> allow min/max in either order</param>
        /// <returns><#= typeName #></returns>
        public static <#= typeName #> GetUpperBound(<#= typeName #> min, <#= typeName #> max, bool allowEitherOrder)
        {
            return allowEitherOrder
                ? max > min
                    ? max
                    : min
                : max;
        }
        <# if (CanConvertToHexString(typeName)) { #>

        /// <summary>
        /// Converts the value to a Hex string
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>Hex string</returns>
        public static string ToHexString(this <#= typeName #> value)
        {
            return $"{value:X2}";
        }

        /// <summary>
        /// Converts the values to a Hex string
        /// </summary>
        /// <param name="values">The values.</param>
        /// <returns>Hex string</returns>
        public static string ToHexString(this IList<<#= typeName #>> values)
        {
            if (values == null)
                return null;

            var sb = new StringBuilder();

            values
                .ToList()
                .ForEach(v => sb.Append(v.ToHexString()));

            return sb.ToString();
        }
<# } #>
    }
<#	manager.EndBlock();
} #>
<# manager.StartFooter(); #>
}
<# manager.EndBlock(); #>

<# manager.Process(true); #>
